package dk.dbc.dataio.flowstore.ejb;

import dk.dbc.dataio.commons.utils.json.JsonException;
import dk.dbc.dataio.flowstore.entity.Flow;
import dk.dbc.dataio.flowstore.entity.FlowBinder;
import dk.dbc.dataio.flowstore.entity.FlowBinderSearchIndexEntry;
import dk.dbc.dataio.flowstore.entity.Submitter;
import dk.dbc.dataio.flowstore.exception.ReferencedEntityNotFoundException;
import dk.dbc.dataio.flowstore.util.ServiceUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;
import java.util.HashSet;
import java.util.Set;

/**
 * This Enterprise Java Bean (EJB) class acts as a JAX-RS root resource
 * exposed by the '{@value #FLOW_BINDERS_ENTRY_POINT}' entry point
 */
@Stateless
@Path(FlowBindersBean.FLOW_BINDERS_ENTRY_POINT)
public class FlowBindersBean {
    public static final String FLOW_BINDERS_ENTRY_POINT = "binders";

    private static final Logger log = LoggerFactory.getLogger(FlowBindersBean.class);

    @PersistenceContext
    private EntityManager entityManager;

    /**
     * Creates new flow binder with data POST'ed as JSON and persists it in the
     * underlying data store.
     *
     * Note: this method updates multiple database tables assuming transactional integrity
     *
     * @param uriInfo application and request URI information
     * @param flowBinderData flow binder data as JSON string
     *
     * @return a HTTP 201 CREATED response with a Location header containing the URL value of the newly created resource.
     *         a HTTP 406 NOT_ACCEPTABLE response on invalid json content.
     *         a HTTP 409 CONFLICT response if violating any uniqueness constraints.
     *         a HTTP 410 GONE if a referenced submitter or flow no longer exists.
     *         a HTTP 500 INTERNAL_SERVER_ERROR response in case of general error.
     *
     * @throws JsonException when given invalid (null-valued, empty-valued or non-json)
     *                       JSON string, or if JSON object does not comply with model schema
     */
    @POST
    @Consumes({ MediaType.APPLICATION_JSON })
    public Response createFlowBinder(@Context UriInfo uriInfo, String flowBinderData) throws JsonException, ReferencedEntityNotFoundException {
        log.trace("Called with: '{}'", flowBinderData);

        /* ATTENTION:
           Below we rely on the transactional integrity provided by the underlying relational
           database system and Java EE, so that if the persisting of a search index entry fails
           the persisted flow binder will be automatically rolled back. This will have to be
           handled differently in case the underlying data store no longer supports transactions.
        */

        /* We set the JSON content for a new FlowBinder instance causing the IDs of referenced
           flow and submitters to be made available. We then resolve these references into
           entities and attaches them to the flow binder causing foreign key relations to be
           created. Finally we generate the search index entries generated by this flow binder
           and persists them in the data store.
         */

        final FlowBinder flowBinder = new FlowBinder();
        flowBinder.setContent(flowBinderData);
        flowBinder.setFlow(resolveFlow(flowBinder.getFlowId()));
        flowBinder.setSubmitters(resolveSubmitterIds(flowBinder.getSubmitterIds()));
        entityManager.persist(flowBinder);

        for (FlowBinderSearchIndexEntry searchIndexEntry : FlowBinder.generateSearchIndexEntries(flowBinder)) {
            entityManager.persist(searchIndexEntry);
        }

        entityManager.flush();

        return Response.created(ServiceUtil.getResourceUriOfVersionedEntity(uriInfo.getAbsolutePathBuilder(), flowBinder)).build();
    }

    /**
     * Resolves each submitter referenced in given set by looking up the corresponding
     * submitter entity in the data store
     *
     * @param submitterIds set of submitter identifiers
     * @return set of submitter entities
     * @throws ReferencedEntityNotFoundException if unable to find a referenced submitter entity in the data store
     */
    private Set<Submitter> resolveSubmitterIds(Set<Long> submitterIds) throws JsonException, ReferencedEntityNotFoundException  {
        final Set<Submitter> submitters = new HashSet<>(submitterIds.size());
        for (Long submitterId : submitterIds) {
            log.trace("Looking up Submitter entity for ID {}", submitterId);
            final Submitter submitter = entityManager.find(Submitter.class, submitterId);
            if (submitter == null) {
                throw new ReferencedEntityNotFoundException(String.format("Submitter(%d)", submitterId));
            }
            submitters.add(submitter);
        }
        log.debug("Resolved {} submitters from '{}' field", submitters.size(), FlowBinder.SUBMITTER_IDS_FIELD);
        return submitters;
    }

    /**
     * Resolves flow referenced by given id by looking up the corresponding flow entity in the
     * data store
     *
     * @param flowId flow identifier
     * @return flow entity
     * @throws ReferencedEntityNotFoundException if unable to find the referenced flow entity in the data store
     */
    private Flow resolveFlow(Long flowId) throws JsonException, ReferencedEntityNotFoundException {
        log.trace("Looking up Flow entity for ID {}", flowId);
        final Flow flow = entityManager.find(Flow.class, flowId);
        if (flow == null) {
            throw new ReferencedEntityNotFoundException(String.format("Flow(%d)", flowId));
        }
        return flow;
    }
}
