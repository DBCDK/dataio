package dk.dbc.dataio.commons.types;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import dk.dbc.invariant.InvariantUtil;

import java.io.Serializable;
import java.util.Arrays;

/**
 * Job specification DTO class.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class JobSpecification implements Serializable {
    private static final long serialVersionUID = 731600708416455339L;
    public static final String EMPTY_MAIL_FOR_NOTIFICATION_ABOUT_VERIFICATION = "";
    public static final String EMPTY_MAIL_FOR_NOTIFICATION_ABOUT_PROCESSING = "";
    public static final String EMPTY_RESULT_MAIL_INITIALS = "";
    public static int JOB_EXPIRATION_AGE_IN_DAYS = 365;

    public enum Type {
        TRANSIENT,
        PERSISTENT,
        TEST,
        ACCTEST("processor::acctest"),
        INFOMEDIA,
        PERIODIC,
        COMPACTED,
        SUPER_TRANSIENT;

        public final String processorQueue;

        Type(String processorQueue) {
            this.processorQueue = processorQueue;
        }

        Type() {
            this.processorQueue = "processor::business";
        }
    }

    private String packaging;
    private String format;
    private String charset;
    private String destination;
    private long submitterId;
    private String mailForNotificationAboutVerification;
    private String mailForNotificationAboutProcessing;
    private String resultmailInitials;
    // Due to GWT serialization issues we cannot use java.net.URI or java.net.URL
    private String dataFile;
    private Type type;
    private Ancestry ancestry;

    @JsonCreator
    public JobSpecification() {
    }

    public static JobSpecification from(JobSpecification jobSpecification) {
        JobSpecification newJobSpecification = new JobSpecification();
        newJobSpecification.packaging = jobSpecification.packaging;
        newJobSpecification.format = jobSpecification.format;
        newJobSpecification.charset = jobSpecification.charset;
        newJobSpecification.destination = jobSpecification.destination;
        newJobSpecification.submitterId = jobSpecification.submitterId;
        newJobSpecification.mailForNotificationAboutVerification = jobSpecification.mailForNotificationAboutVerification;
        newJobSpecification.mailForNotificationAboutProcessing = jobSpecification.mailForNotificationAboutProcessing;
        newJobSpecification.resultmailInitials = jobSpecification.resultmailInitials;
        newJobSpecification.dataFile = jobSpecification.dataFile;
        newJobSpecification.type = jobSpecification.type;
        newJobSpecification.ancestry = jobSpecification.ancestry;
        return newJobSpecification;
    }

    public String getCharset() {
        return charset;
    }

    public JobSpecification withCharset(String charset) {
        this.charset = InvariantUtil.checkNotNullNotEmptyOrThrow(charset, "charset");
        return this;
    }

    public String getDataFile() {
        return dataFile;
    }

    public JobSpecification withDataFile(String dataFile) {
        this.dataFile = InvariantUtil.checkNotNullNotEmptyOrThrow(dataFile, "dataFile");
        return this;
    }

    public String getDestination() {
        return destination;
    }

    public JobSpecification withDestination(String destination) {
        this.destination = InvariantUtil.checkNotNullNotEmptyOrThrow(destination, "destination");
        return this;
    }

    public String getFormat() {
        return format;
    }

    public JobSpecification withFormat(String format) {
        this.format = InvariantUtil.checkNotNullNotEmptyOrThrow(format, "format");
        return this;
    }

    public String getPackaging() {
        return packaging;
    }

    public JobSpecification withPackaging(String packaging) {
        this.packaging = InvariantUtil.checkNotNullNotEmptyOrThrow(packaging, "packaging").trim().toLowerCase();
        return this;
    }

    // Submitter id represents the unique submitter number and not the id generated by the system when a new submitter is created
    public long getSubmitterId() {
        return submitterId;
    }

    public JobSpecification withSubmitterId(long submitterId) {
        if (submitterId < Constants.PERSISTENCE_ID_LOWER_BOUND) {
            final String message = "Value of parameter submitterId must be larger than or equal to " + Constants.PERSISTENCE_ID_LOWER_BOUND;
            throw new IllegalArgumentException(message);
        } else {
            this.submitterId = submitterId;
            return this;
        }
    }

    public String getMailForNotificationAboutVerification() {
        return mailForNotificationAboutVerification;
    }

    public JobSpecification withMailForNotificationAboutVerification(String mailForNotificationAboutVerification) {
        this.mailForNotificationAboutVerification = InvariantUtil.checkNotNullOrThrow(mailForNotificationAboutVerification, "mailForNotificationAboutVerification");
        return this;
    }

    public String getMailForNotificationAboutProcessing() {
        return mailForNotificationAboutProcessing;
    }

    public JobSpecification withMailForNotificationAboutProcessing(String mailForNotificationAboutProcessing) {
        this.mailForNotificationAboutProcessing = InvariantUtil.checkNotNullOrThrow(mailForNotificationAboutProcessing, "mailForNotificationAboutProcessing");
        return this;
    }

    public String getResultmailInitials() {
        return resultmailInitials;
    }

    public JobSpecification withResultmailInitials(String resultmailInitials) {
        this.resultmailInitials = InvariantUtil.checkNotNullOrThrow(resultmailInitials, "resultmailInitials");
        return this;
    }

    public Type getType() {
        return type;
    }

    public JobSpecification withType(Type type) {
        this.type = InvariantUtil.checkNotNullOrThrow(type, "type");
        return this;
    }

    public Ancestry getAncestry() {
        return ancestry;
    }

    public JobSpecification withAncestry(Ancestry ancestry) {
        this.ancestry = ancestry;
        return this;
    }

    @JsonIgnore
    public boolean hasNotificationDestination() {
        return !(mailForNotificationAboutVerification == null || mailForNotificationAboutVerification.trim().isEmpty())
                || !(mailForNotificationAboutProcessing == null || mailForNotificationAboutProcessing.trim().isEmpty());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof JobSpecification)) return false;

        JobSpecification that = (JobSpecification) o;

        if (submitterId != that.submitterId) return false;
        if (packaging != null ? !packaging.equals(that.packaging) : that.packaging != null) return false;
        if (format != null ? !format.equals(that.format) : that.format != null) return false;
        if (charset != null ? !charset.equals(that.charset) : that.charset != null) return false;
        if (destination != null ? !destination.equals(that.destination) : that.destination != null) return false;
        if (mailForNotificationAboutVerification != null ? !mailForNotificationAboutVerification.equals(that.mailForNotificationAboutVerification) : that.mailForNotificationAboutVerification != null)
            return false;
        if (mailForNotificationAboutProcessing != null ? !mailForNotificationAboutProcessing.equals(that.mailForNotificationAboutProcessing) : that.mailForNotificationAboutProcessing != null)
            return false;
        if (resultmailInitials != null ? !resultmailInitials.equals(that.resultmailInitials) : that.resultmailInitials != null)
            return false;
        if (dataFile != null ? !dataFile.equals(that.dataFile) : that.dataFile != null) return false;
        if (type != that.type) return false;
        return ancestry != null ? ancestry.equals(that.ancestry) : that.ancestry == null;
    }

    @Override
    public int hashCode() {
        int result = packaging != null ? packaging.hashCode() : 0;
        result = 31 * result + (format != null ? format.hashCode() : 0);
        result = 31 * result + (charset != null ? charset.hashCode() : 0);
        result = 31 * result + (destination != null ? destination.hashCode() : 0);
        result = 31 * result + (int) (submitterId ^ (submitterId >>> 32));
        result = 31 * result + (mailForNotificationAboutVerification != null ? mailForNotificationAboutVerification.hashCode() : 0);
        result = 31 * result + (mailForNotificationAboutProcessing != null ? mailForNotificationAboutProcessing.hashCode() : 0);
        result = 31 * result + (resultmailInitials != null ? resultmailInitials.hashCode() : 0);
        result = 31 * result + (dataFile != null ? dataFile.hashCode() : 0);
        result = 31 * result + (type != null ? type.hashCode() : 0);
        result = 31 * result + (ancestry != null ? ancestry.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return "JobSpecification{" +
                "packaging='" + packaging + '\'' +
                ", format='" + format + '\'' +
                ", charset='" + charset + '\'' +
                ", destination='" + destination + '\'' +
                ", submitterId=" + submitterId +
                ", mailForNotificationAboutVerification='" + mailForNotificationAboutVerification + '\'' +
                ", mailForNotificationAboutProcessing='" + mailForNotificationAboutProcessing + '\'' +
                ", resultmailInitials='" + resultmailInitials + '\'' +
                ", dataFile='" + dataFile + '\'' +
                ", type='" + type + '\'' +
                ", ancestry='" + ancestry + '\'' +
                '}';
    }

    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class Ancestry implements Serializable {
        private static final long serialVersionUID = 7924802481866401011L;
        private String harvesterToken;
        private String transfile;
        private String datafile;
        private String batchId;
        private byte[] details;
        private int previousJobId;

        public Ancestry() {
        }

        public String getHarvesterToken() {
            return harvesterToken;
        }

        public Ancestry withHarvesterToken(String harvesterToken) throws IllegalArgumentException {
            this.harvesterToken = InvariantUtil.checkNotEmptyOrThrow(harvesterToken, "harvesterToken");
            return this;
        }

        public String getTransfile() {
            return transfile;
        }

        public Ancestry withTransfile(String transfile) throws IllegalArgumentException {
            this.transfile = InvariantUtil.checkNotEmptyOrThrow(transfile, "transfile");
            return this;
        }

        public String getDatafile() {
            return datafile;
        }

        public Ancestry withDatafile(String datafile) throws IllegalArgumentException {
            this.datafile = InvariantUtil.checkNotEmptyOrThrow(datafile, "datafile");
            return this;
        }

        public String getBatchId() {
            return batchId;
        }

        public Ancestry withBatchId(String batchId) {
            this.batchId = batchId;
            return this;
        }

        public byte[] getDetails() {
            return details;
        }

        public Ancestry withDetails(byte[] details) {
            this.details = details;
            return this;
        }

        public int getPreviousJobId() {
            return previousJobId;
        }

        public Ancestry withPreviousJobId(int previousJobId) {
            this.previousJobId = previousJobId;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            Ancestry ancestry = (Ancestry) o;

            if (previousJobId != ancestry.previousJobId) {
                return false;
            }
            if (harvesterToken != null ? !harvesterToken.equals(ancestry.harvesterToken) : ancestry.harvesterToken != null) {
                return false;
            }
            if (transfile != null ? !transfile.equals(ancestry.transfile) : ancestry.transfile != null) {
                return false;
            }
            if (datafile != null ? !datafile.equals(ancestry.datafile) : ancestry.datafile != null) {
                return false;
            }
            if (batchId != null ? !batchId.equals(ancestry.batchId) : ancestry.batchId != null) {
                return false;
            }
            return Arrays.equals(details, ancestry.details);

        }

        @Override
        public int hashCode() {
            int result = harvesterToken != null ? harvesterToken.hashCode() : 0;
            result = 31 * result + (transfile != null ? transfile.hashCode() : 0);
            result = 31 * result + (datafile != null ? datafile.hashCode() : 0);
            result = 31 * result + (batchId != null ? batchId.hashCode() : 0);
            result = 31 * result + Arrays.hashCode(details);
            result = 31 * result + previousJobId;
            return result;
        }

        @Override
        public String toString() {
            return "Ancestry{" +
                    "harvesterToken='" + harvesterToken + '\'' +
                    ", transfile='" + transfile + '\'' +
                    ", datafile='" + datafile + '\'' +
                    ", batchId='" + batchId + '\'' +
                    ", details=" + Arrays.toString(details) +
                    ", previousJobId=" + previousJobId +
                    '}';
        }
    }
}
