package dk.dbc.dataio.flowstore.entity;

import dk.dbc.dataio.commons.utils.invariant.InvariantUtil;
import dk.dbc.dataio.flowstore.util.json.JsonException;
import dk.dbc.dataio.flowstore.util.json.JsonUtil;
import org.codehaus.jackson.JsonNode;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.Lob;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.UniqueConstraint;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Persistence domain class for flow binder objects where id is auto
 * generated by the underlying store and the data content is
 * given as JSON string.
 *
 * Note that this entity contains foreign key relations to its attached submitters.
 */
@Entity
@Table(name = FlowBinder.TABLE_NAME,
uniqueConstraints = {
    @UniqueConstraint(columnNames = { FlowBinder.NAME_INDEX_COLUMN }),
})
public class FlowBinder extends VersionedEntity {
    public static final String TABLE_NAME = "flow_binders";
    public static final String SUBMITTER_JOIN_TABLE_NAME = "flow_binders_submitters";

    public static final String NAME_FIELD = "name";
    public static final String PACKAGING_FIELD = "packaging";
    public static final String FORMAT_FIELD = "format";
    public static final String CHARSET_FIELD = "charset";
    public static final String DESTINATION_FIELD = "destination";
    public static final String FLOW_ID_FIELD = "flowId";
    public static final String SUBMITTER_IDS_FIELD = "submitterIds";

    static final String NAME_INDEX_COLUMN = "name_idx";
    static final String BINDER_JOIN_COLUMN = "flow_binder_id";
    static final String SUBMITTER_JOIN_COLUMN = "submitter_id";

    @Lob
    @Column(name = NAME_INDEX_COLUMN, nullable = false)
    private String nameIndexValue;

    @OneToMany(fetch = FetchType.LAZY)
    @JoinTable(name = SUBMITTER_JOIN_TABLE_NAME,
            joinColumns = @JoinColumn(name = BINDER_JOIN_COLUMN),
            inverseJoinColumns = @JoinColumn(name = SUBMITTER_JOIN_COLUMN))
    private Set<Submitter> submitters;

    // ToDo: enable foreign key mapping when Flow entity is updated to extend VersionedEntity.
    //@OneToOne(fetch = FetchType.LAZY)
    //private Flow flow;
    private Long flow;

    @Transient
    private Set<Long> submitterIds;

    public Set<Long> getSubmitterIds() {
        return new HashSet<>(submitterIds);
    }

    public void setSubmitters(Set<Submitter> submitters) {
        this.submitters = new HashSet<>(submitters);
    }

    /**
     * {@inheritDoc}
     * @throws JsonException if given invalid (null-valued, empty-valued or non-json) JSON string.
     *                       If '{@value #NAME_FIELD}', '{@value #PACKAGING_FIELD}', '{@value #FORMAT_FIELD}',
     *                       '{@value #CHARSET_FIELD}', or '{@value #DESTINATION_FIELD}'  field of given json
     *                       data does not exists, is null, is empty or is non-textual. If unable to extract
     *                       submitter IDs from '{@value #SUBMITTER_IDS_FIELD}'. If unable to extract flow ID
     *                       from  '{@value #FLOW_ID_FIELD}'.
     */
    @Override
    protected void preProcessContent(String flowBinderData) throws JsonException {
        final JsonNode json = JsonUtil.getJsonRoot(flowBinderData);
        nameIndexValue = JsonUtil.getNonEmptyTextValueOrThrow(json.path(NAME_FIELD), NAME_FIELD);
        submitterIds = extractSubmitterIdsFromJson(json);
        flow = extractFlowIdFromJson(json);
    }

    /* Extracts IDs of submitters referenced by this flow binder
     */
    private Set<Long> extractSubmitterIdsFromJson(JsonNode json) throws JsonException {
        final JsonNode submitterIdsNode = json.get(SUBMITTER_IDS_FIELD);
        final Set<Long> submitterIds;
        if (submitterIdsNode != null && submitterIdsNode.isArray()) {
            submitterIds = new HashSet<>(submitterIdsNode.size());
            for (final JsonNode idNode : submitterIdsNode) {
                final long submitterId = JsonUtil.getLongValueOrThrow(idNode, FlowBinder.SUBMITTER_IDS_FIELD);
                submitterIds.add(submitterId);
            }
        } else {
            throw new JsonException(String.format("No array value found for field '%s'", SUBMITTER_IDS_FIELD));
        }
        return submitterIds;
    }

    /* Extracts ID of flow referenced by this flow binder
     */
    private Long extractFlowIdFromJson(JsonNode json) throws JsonException {
        final JsonNode flowIdNode = json.get(FLOW_ID_FIELD);
        return JsonUtil.getLongValueOrThrow(flowIdNode, FLOW_ID_FIELD);
    }

    /**
     * Generates search index entries for given flow binder
     *
     * @param flowBinder flow binder instance
     *
     * @return list of search index entries
     *
     * @throws NullPointerException if given null-valued flow binder
     * @throws JsonException if flow binder contains invalid JSON content
     */
    public static List<FlowBinderSearchIndexEntry> generateSearchIndexEntries(final FlowBinder flowBinder) throws JsonException {
        InvariantUtil.checkNotNullOrThrow(flowBinder, "flowBinder");
        final JsonNode json = JsonUtil.getJsonRoot(flowBinder.getContent());
        final String packaging = JsonUtil.getNonEmptyTextValueOrThrow(json.path(PACKAGING_FIELD), PACKAGING_FIELD);
        final String format = JsonUtil.getNonEmptyTextValueOrThrow(json.path(FORMAT_FIELD), FORMAT_FIELD);
        final String charset = JsonUtil.getNonEmptyTextValueOrThrow(json.path(CHARSET_FIELD), CHARSET_FIELD);
        final String destination = JsonUtil.getNonEmptyTextValueOrThrow(json.path(DESTINATION_FIELD), DESTINATION_FIELD);
        final List<FlowBinderSearchIndexEntry> index = new ArrayList<>(flowBinder.getSubmitterIds().size());
        for (final Long submitterId : flowBinder.getSubmitterIds()) {
            final FlowBinderSearchIndexEntry entry = new FlowBinderSearchIndexEntry();
            entry.setPackaging(packaging);
            entry.setFormat(format);
            entry.setCharset(charset);
            entry.setDestination(destination);
            entry.setSubmitter(submitterId);
            entry.setFlowBinder(flowBinder);
            index.add(entry);
        }
        return index;
    }
}
